<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>

<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Chapter 1: Basic Image Processing </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="Introduction"></a>
Introduction</h2>
<p>If you're like me, you prefer to learn by example, so let's jump right into looking at some code. We'll begin by walking through a sample included with the OpenCV CinderBlock, located at <em>blocks/opencv/samples/ocvBasic</em>. This sample loads an image as a resource, and then performs some basic image processing and displays the results. Let's examine the code in detail:<br/>
 </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="_cinder_open_c_v_8h.html">CinderOpenCV.h</a>&quot;</span>
</pre></div><p> Here's the first interesting line. We're just including the OpenCV CinderBlock's header file. This file contains the glue between Cinder and OpenCV, and it in turn includes the relevant headers from OpenCV itself. Next let's look at the setup() method: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> ocvBasicApp::setup()
{
    ci::Surface8u surface( <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#a5091cf493eafbd8741669dfac5188856">loadImage</a>( <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1app.html#a93522b1858f745f7d9438d6d124ae11b">loadResource</a>( RES_IMAGE ) ) );
    <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="ml_8h.html#a8f45a3157cd8bdbb30d638b20fd31f1a">input</a>( toOcv( surface ) );
    <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> output;
    <a class="code" href="namespacecv.html#a73f5d2b1adc7da9cd5e9076b15dbcf3c">cv::medianBlur</a>( input, output, 11 );
    ...
    mTexture = gl::Texture( fromOcv( output ) );
}    
</pre></div><p> <br/>
 The first line should be familiar. We're just creating a <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface</a> by loading an image from a resource. Next, we dive right into some proper OpenCV code. We create two instances OpenCV's <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> class. This class is very similar to Cinder's <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">Surface</a>, and can be used to represent an image. More on this important class later. Notice the constructor parameter for <em>input</em> - the result of a call to toOcv() with the <em>surface</em> we loaded earlier. This is our first exposure to the CinderBlock layer. This function simply translates a Cinder class into a form that is usable directly with OpenCV - in this case a ci::Surface into something suitable to construct a <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> with. We'll get deeper into how the OpenCV CinderBlock works in a bit. The second portion of the line constructs an empy <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> called <em>output</em>.<br/>
 <br/>
 Next, we get into some actual image processing. In this case, we are using OpenCV's <a class="el" href="namespacecv.html#a73f5d2b1adc7da9cd5e9076b15dbcf3c">medianBlur()</a> function, which smooths an image using a median filter. The first parameter is the source <a class="el" href="classcv_1_1_mat.html">cv::Mat</a>, <em>input</em> in our case. The second parameter is the <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> which will hold the result. OpenCV automatically creates a <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> which is of the appropriate size and depth, and in our case will put this result into <em>output</em>. The final parameter is how large a window is examined for computing the median of each pixel - we've selected a kernel size of <code>11</code>.<br/>
 <br/>
 The last line of setup() creates an OpenGL texture used later in draw(). It makes use of the CinderBlock's fromOcv() function, which behaves just like toOcv() does but in the other direction, converting OpenCV's data structures into Cinder's equivalents. Running the sample gives us a smoothed version of our input image, which is <a href="http://www.flickr.com/photos/stuckincustoms/4045813826/">a photograph by Trey Ratcliff</a>.<br/>
<br/>
 </p>
<div align="center">
<img src="ch1_median.jpg" alt="ch1_median.jpg"/>
</div>
<p> <br/>
 <br/>
 Nice. So let's try tweaking this code a bit. Try changing the kernel size from <code>11</code> to something like say, <code>21</code>. Just make sure it's odd and bigger than <code>1</code>. How do I know that? Well, the OpenCV docs told me. Now's a good time to get familiar with what they look like - checkout the <a href="http://opencv.willowgarage.com/documentation/cpp/image_filtering.html#medianBlur">description of medianBlur()</a>. As you learn OpenCV, you'll want to familiarize yourself with these docs, but for now let's keep moving.<br/>
 <br/>
 </p>
<h2>Sobel</h2>
<p>Let's experiment with a different image processing operator. First, comment out the line in setup() which calls <a class="el" href="namespacecv.html#a73f5d2b1adc7da9cd5e9076b15dbcf3c">cv::medianBlur()</a>, and replace it with a call to the Sobel edge detection operator: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//  cv::medianBlur( input, output, 11 );</span>
<a class="code" href="namespacecv.html#abcb8881170fa5008cb2a0a109400f53d">cv::Sobel</a>( input, output, CV_8U, 0, 1 ); 
</pre></div><p> The first two parameters to <a class="el" href="namespacecv.html#abcb8881170fa5008cb2a0a109400f53d">cv::Sobel</a> should be familiar - they're the same as <a class="el" href="namespacecv.html#a73f5d2b1adc7da9cd5e9076b15dbcf3c">cv::medianBlur()</a>. The third parameter is a little different though. Instead of automatically deriving what kind of <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> the output should be from the input, <a class="el" href="namespacecv.html#abcb8881170fa5008cb2a0a109400f53d">cv::Sobel()</a> wants us to tell it what kind of image we want. By passing <code>CV_8U</code> we have asked for an 8-bit unsigned image, which is normal for most image processing. If we wanted say, a floating point image, we could pass <code>CV_32F</code> instead. The fourth and fifth parameters, which are <em>xOrder</em> and <em>yOrder</em> respectively, allow us to select between horizontal and vertical edges. By passing <code>0</code> and <code>1</code>, we have selected the vertical edges. Run this, and you should see a result about like this:<br/>
<br/>
 </p>
<div align="center">
<img src="ch1_sobel_vert.jpg" alt="ch1_sobel_vert.jpg"/>
</div>
<p> <br/>
 There are additional optional parameters to <a class="el" href="namespacecv.html#abcb8881170fa5008cb2a0a109400f53d">cv::Sobel()</a>. Checkout its <a href="http://opencv.willowgarage.com/documentation/cpp/image_filtering.html#Sobel">documentation here</a>. How do the horizontal edges compare? Try swapping the <code>0</code> and <code>1</code>, or experiment with the kernel size parameter the docs mention.<br/>
 <br/>
 </p>
<h2>Threshold</h2>
<p>And now we'll experiment with a final image processing operator, <a href="http://opencv.willowgarage.com/documentation/cpp/miscellaneous_image_transformations.html#cv-threshold">cv::threshold()</a>. The first and second parameters are consistent with <a class="el" href="namespacecv.html#abcb8881170fa5008cb2a0a109400f53d">cv::Sobel()</a> and <a class="el" href="namespacecv.html#a73f5d2b1adc7da9cd5e9076b15dbcf3c">cv::medianBlur()</a> - just the input and output image represented as <a class="el" href="classcv_1_1_mat.html">cv::Mat</a>'s. The third parameter specifies what value defines <em>above</em> and <em>below</em>, and the fourth is the maximum value. Since we're working on 8-bit unsigned images, we'll pass <code>128</code> and <code>255</code> for these two values. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="namespacecv.html#aec98cd2011124ee5a362ef180775e51b">cv::threshold</a>( input, output, 128, 255, CV_8U );
</pre></div><p> <br/>
 </p>
<div align="center">
<img src="ch1_threshold.jpg" alt="ch1_threshold.jpg"/>
</div>
<p> <br/>
 </p>
<h2>More on <a class="el" href="classcv_1_1_mat.html">cv::Mat</a></h2>
<p>The <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> class provides a representation of an image, much like Cinder's <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">Surface</a> or <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">Channel</a> classes. To determine the size of a <a class="el" href="classcv_1_1_mat.html">cv::Mat</a>, use code like this: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> myMat( ... );
<a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1app.html#a72f7349e12a6766075862ed953868abe">console</a>() &lt;&lt; <span class="stringliteral">&quot;myMat is &quot;</span> &lt;&lt; myMat.size().width &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; myMat.size().height &lt;&lt; <span class="stringliteral">&quot; pixels.&quot;</span> &lt;&lt; std::endl;
</pre></div><p> The design of <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> is also quite similar to <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface</a> or <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">ci::Channel</a> with respect to memory management. Like these Cinder classes, <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> maintains a reference count, automatically freeing the associated memory when the refence count drops to zero. Furthermore, assigning one <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> to another is fast, since no image data is copied - just pointers to image data. This means you're safe passing <a class="el" href="classcv_1_1_mat.html">cv::Mat</a>'s by value (again, just like <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface</a> or <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">ci::Channel</a>). </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> matA( toOcv( <span class="stringliteral">&quot;C:\\imageA.png&quot;</span> ) );
<a class="code" href="classcv_1_1_mat.html">cv::Mat</a> matB = matA; <span class="comment">// matB and matA both reference the same image</span>
<a class="code" href="classcv_1_1_mat.html">cv::Mat</a> matC( toOcv( <span class="stringliteral">&quot;C:\\imageC.png&quot;</span> ) );
matC = matA; <span class="comment">// the image matC was constructed with gets freed automatically here</span>
</pre></div><p>Also just like Cinder's equivalent classes, you can allocate a <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> which is empy - the equivalent of a null pointer. To test for null with <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface</a>, we write something about like </p>
<div class="fragment"><pre class="fragment"><a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#a7f62055e4cb811edb9868b32595a1d64">Surface</a> mySurface( ... );
<span class="keywordflow">if</span>( mySurface )
    ... <span class="keywordflow">do</span> something with non-null mySurface ...
</pre></div><p> To perform the equivalent null-test with <a class="el" href="classcv_1_1_mat.html">cv::Mat</a>, use code like this: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> myMat( ... );
<span class="keywordflow">if</span>( myMat.data() )
    ... <span class="keywordflow">do</span> something with non-null myMat ...
</pre></div><p> <br/>
 A key difference between <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> and <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">Surface</a> or <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">Channel</a> is that a <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> can contain an image of many different varieties. While say, Cinder's <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#ad8b046fa928d58861b60465ceda392c5">Surface8u</a> class always represents an RGB(A) 8-bit image, a <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> might represent a 32-bit floating point RGB image, or an 8-bit grayscale image, or perhaps a 16-bit YUV image. To determine what sort of data the <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> contains, use <a href="http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#cv-mat-type">cv::Mat::type()</a>. This will return a value we can compare against constants like <code>CV_8U3</code>, which implies an 8-bit unsigned, 3-color image (corresponding to a <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface8u</a> with no alpha channel), or say, <code>CV_32F1</code>, which corresponds to a <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">ci::Channel32f</a>. These constants take the form <code>CV_</code>&lt;bit-depth&gt;{<code>U</code> | <code>S</code> | <code>F</code> }&lt;number-of-channels&gt;, and are discussed in <a href="http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#datatype">detail here</a>. </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span>( input.type() == CV_8U3 )
    ... <span class="keywordflow">do</span> something with a 3 channel, 8-bit <a class="code" href="cvaux_8h.html#a35b1e6246c0baa4fe7c8a916316d3adc">image</a> ...
<span class="keywordflow">else</span> <span class="keywordflow">if</span>( input.type() == CV_32F3 )
    ... <span class="keywordflow">do</span> something with a 3 channel, 32-bit <span class="keywordtype">float</span> <a class="code" href="cvaux_8h.html#a35b1e6246c0baa4fe7c8a916316d3adc">image</a> ...
<span class="keywordflow">else</span>
    ... fail gracefully ...
</pre></div><p> <br/>
 </p>
<h2>The OpenCV CinderBlock</h2>
<p>The OpenCV CinderBlock has been designed to offer a combination of performance, flexibility and convenience. Rather than imposing an additional API users must learn and which must be maintained as OpenCV itself evolves, the CinderBlock consists of essentially just two overloaded functions, ci::toOcv(), and ci::fromOcv(). Armed with these, you can easily exchange data structures between OpenCV and Cinder. We have seen both used in the example code above: </p>
<div class="fragment"><pre class="fragment">ci::Surface8u surface( <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#a5091cf493eafbd8741669dfac5188856">loadImage</a>( <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1app.html#a93522b1858f745f7d9438d6d124ae11b">loadResource</a>( RES_IMAGE ) ) );
<a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="ml_8h.html#a8f45a3157cd8bdbb30d638b20fd31f1a">input</a>( toOcv( surface ) ), output;
...
mTexture = gl::Texture( fromOcv( output ) );
</pre></div><p> Note that the first two lines could be condensed into one: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="ml_8h.html#a8f45a3157cd8bdbb30d638b20fd31f1a">input</a>( toOcv( <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#a5091cf493eafbd8741669dfac5188856">loadImage</a>( <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1app.html#a93522b1858f745f7d9438d6d124ae11b">loadResource</a>( RES_IMAGE ) ) ) ), output;
</pre></div><p> Note also that we can pass the result of ci::fromOcv(cv::Mat) to functions like writeImage directly: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/_image_io_8h.html">cinder/ImageIo.h</a>&quot;</span>
<a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#aa665b20560506c98707c15d3fb594c06">writeImage</a>( <span class="stringliteral">&quot;openCV_output.png&quot;</span>, fromOcv( output ) );
</pre></div><p> <br/>
 </p>
<h2>The OpenCV C++ API</h2>
<p>If you've worked with OpenCV in the past, particularly older versions, you may be familiar with its procedural API. In more recent releases, OpenCV has introduced an object-oriented C++ API which allows greater brevity and is type-safe. The OpenCV CinderBlock is based upon this more modern API. However if you are working with legacy code, or you simply prefer it, you can still call the procedural API, passing <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> instances in place of <code>IplImages</code> or <code>Arr*</code>. For example, the two calls below are equivalent: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="ml_8h.html#a8f45a3157cd8bdbb30d638b20fd31f1a">input</a>( ... ), output;
cvLaplace( input, output, CV_8U ); <span class="comment">// call the C function</span>
<a class="code" href="namespacecv.html#a98c85dc3610d02e778c240340cd96485">cv::Laplacian</a>( input, output, CV_8U ); <span class="comment">// call the C++ function</span>
</pre></div><p> A helpful introduction to the C++ API <a href="http://opencv.willowgarage.com/documentation/cpp/introduction.html">is available here</a>. <br/>
</p>
<h2>Exercises</h2>
<p>1. Experiment with combining these basic OpenCV operators. How does the order of operations affect things? What happens if you run a threshold operator on top of a Sobel operator? What about a Sobel operator on top of a threshold operator?<br/>
 2. Try making one of the image processing parameters (like the value parameter for cv::Threshold) user-controllable using <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1params_1_1_interface_gl.html">params::InterfaceGl</a>. If you've never made use of this feature of Cinder, start with the sample in <em>cinder/samples/paramsBasic</em>.<br/>
 3. Adapt this sample to work based on the real-time input of a webcam using Capture, or the frames of a QuickTime movie using <a class="elRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1qtime_1_1_movie_surface.html">qtime::MovieSurface</a>. <br/>
 </p>
</div>
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>
